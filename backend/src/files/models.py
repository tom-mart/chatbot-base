"""
File management models for user uploads and tool-generated files.
"""
from django.db import models
from django.contrib.auth.models import User
from django.core.validators import FileExtensionValidator
import uuid
import os


def user_upload_path(instance, filename):
    """Generate upload path for user files"""
    ext = filename.split('.')[-1]
    filename = f"{uuid.uuid4()}.{ext}"
    return f"uploads/{instance.user.id}/{instance.category}/{filename}"


def tool_output_path(instance, filename):
    """Generate path for tool-generated files"""
    ext = filename.split('.')[-1]
    filename = f"{uuid.uuid4()}.{ext}"
    return f"tool_outputs/{instance.user.id}/{instance.tool_name}/{filename}"


class UserFile(models.Model):
    """
    Represents a file uploaded by user or generated by a tool.
    """
    FILE_CATEGORIES = [
        ('receipt', 'Receipt'),
        ('document', 'Document'),
        ('image', 'Image'),
        ('audio', 'Audio'),
        ('video', 'Video'),
        ('pdf', 'PDF'),
        ('other', 'Other'),
    ]
    
    FILE_SOURCES = [
        ('user_upload', 'User Upload'),
        ('tool_generated', 'Tool Generated'),
        ('tool_downloaded', 'Tool Downloaded'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='files')
    
    # File metadata
    file = models.FileField(upload_to=user_upload_path)
    original_filename = models.CharField(max_length=255)
    file_size = models.BigIntegerField(help_text="File size in bytes")
    mime_type = models.CharField(max_length=100)
    category = models.CharField(max_length=50, choices=FILE_CATEGORIES, default='other')
    
    # Source tracking
    source = models.CharField(max_length=50, choices=FILE_SOURCES, default='user_upload')
    tool_name = models.CharField(max_length=100, blank=True, null=True, 
                                 help_text="Tool that generated/downloaded this file")
    tool_execution_id = models.UUIDField(blank=True, null=True,
                                         help_text="Reference to ToolExecution")
    
    # Optional associations
    conversation_id = models.UUIDField(blank=True, null=True,
                                       help_text="Associated conversation")
    checkin_id = models.UUIDField(blank=True, null=True,
                                  help_text="Associated check-in")
    
    # Metadata
    description = models.TextField(blank=True)
    tags = models.JSONField(default=list, blank=True)
    metadata = models.JSONField(default=dict, blank=True,
                               help_text="Additional metadata (OCR text, music info, etc.)")
    
    # Status
    is_temporary = models.BooleanField(default=False,
                                      help_text="Temporary files are auto-deleted after 24h")
    is_processed = models.BooleanField(default=False,
                                      help_text="Whether file has been processed by tools")
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    expires_at = models.DateTimeField(blank=True, null=True,
                                     help_text="Auto-delete after this time")
    
    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', 'category']),
            models.Index(fields=['user', 'source']),
            models.Index(fields=['tool_name']),
            models.Index(fields=['is_temporary', 'expires_at']),
        ]
    
    def __str__(self):
        return f"{self.original_filename} ({self.user.username})"
    
    @property
    def file_url(self):
        """Get the file URL"""
        if self.file:
            return self.file.url
        return None
    
    @property
    def download_url(self):
        """Get the download URL"""
        return f"/api/files/{self.id}/download"
    
    def delete(self, *args, **kwargs):
        """Delete file from storage when model is deleted"""
        if self.file:
            if os.path.isfile(self.file.path):
                os.remove(self.file.path)
        super().delete(*args, **kwargs)


class FileShare(models.Model):
    """
    Share files with other users or generate public links.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    file = models.ForeignKey(UserFile, on_delete=models.CASCADE, related_name='shares')
    
    # Sharing options
    share_token = models.CharField(max_length=64, unique=True, db_index=True)
    is_public = models.BooleanField(default=False,
                                    help_text="Public link accessible without auth")
    shared_with = models.ForeignKey(User, on_delete=models.CASCADE, 
                                    blank=True, null=True,
                                    related_name='shared_files',
                                    help_text="Specific user to share with")
    
    # Access control
    max_downloads = models.IntegerField(blank=True, null=True,
                                       help_text="Maximum number of downloads allowed")
    download_count = models.IntegerField(default=0)
    expires_at = models.DateTimeField(blank=True, null=True)
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    last_accessed = models.DateTimeField(blank=True, null=True)
    
    class Meta:
        ordering = ['-created_at']
    
    def __str__(self):
        return f"Share: {self.file.original_filename} ({self.share_token[:8]}...)"
    
    @property
    def is_expired(self):
        """Check if share link has expired"""
        from django.utils import timezone
        if self.expires_at and self.expires_at < timezone.now():
            return True
        if self.max_downloads and self.download_count >= self.max_downloads:
            return True
        return False


class StorageQuota(models.Model):
    """
    Track storage usage per user with quotas.
    """
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='storage_quota')
    
    # Quota limits (in bytes)
    total_quota = models.BigIntegerField(default=1073741824,  # 1GB default
                                        help_text="Total storage quota in bytes")
    used_storage = models.BigIntegerField(default=0,
                                         help_text="Currently used storage in bytes")
    
    # File count limits
    max_files = models.IntegerField(default=1000)
    file_count = models.IntegerField(default=0)
    
    # Timestamps
    last_calculated = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name_plural = 'Storage Quotas'
    
    def __str__(self):
        return f"{self.user.username}: {self.used_storage}/{self.total_quota} bytes"
    
    @property
    def usage_percentage(self):
        """Calculate storage usage percentage"""
        if self.total_quota == 0:
            return 0
        return (self.used_storage / self.total_quota) * 100
    
    @property
    def available_storage(self):
        """Get available storage in bytes"""
        return max(0, self.total_quota - self.used_storage)
    
    def recalculate_usage(self):
        """Recalculate storage usage from actual files"""
        from django.db.models import Sum, Count
        
        stats = self.user.files.aggregate(
            total_size=Sum('file_size'),
            total_count=Count('id')
        )
        
        self.used_storage = stats['total_size'] or 0
        self.file_count = stats['total_count'] or 0
        self.save()
        
        return self.used_storage
